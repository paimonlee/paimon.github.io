# 基本语法

汇编程序可以分为三个段

* data段
* bss段
* text段

## data段

数据段被用于声明初始化的数据或常数。此数据在运行时不会更改。可以在段中声明各种常用值，文件名或缓冲区大小等。

```nasm
section.data
```

## bss段

在bss声明变量。

```nasm
section.bss


```

## text段

代码段被用于保持实际的代码。该段必须以全集声明_start开头，该声明告诉内核程序从何处开始执行。

```nasm
section.test
    global _start
_start:
```

## 注释

汇编语言注释以分号(;)开头。它可以包含任何可打印字符，包括空格。它可以单独出现在一行上。

```nasm
;该程序在屏幕上显示一条信息
```

或者，与指令在同一行上。

```nasm
add eax, ebx ;加上ebx的值到eax
```

## 汇编语言声明

汇编语言程序包含三种类型的语句

* 可执行指令或说明
* 汇编程序指令或伪操作
* 宏

可执行指令或简单的指令告诉处理器做什么。每个指令由一个操作码组成。每个可执行指令生成一个机器语言指令。该汇编指令或位操作讲述装配过程中的各方面的汇编。这些是不可执行的，不会生成机器语言指令。宏是一种代码替换机制。

## 汇编语言语句的语法

汇编语言语句每行输入一个语句。每个语句遵循一下格式

```nasm
[label] mnemonic [operands] [;comment]
```

基本命令包括两段，第一段是要执行的指令（或助记符）的名称，第二段是命令的操作数或参数。以下是一些典型汇编语句的示例

```nasm
inc count         ; 增加内存变量count
mov total, 48     ; 将值48转移到内存变量total
add ah,bh         ; 将寄存器BH内容添加到ah寄存器
and mask1, 128    ; 对变量mask1 和 128执行and操作

add marks, 10     ; 将10加到变量marks
mov al, 10        ; 将值10传送到al寄存器
```

## 汇编语言的Hello World 程序

```nasm
section .text
	global _start
_start:
	mov edx,len	; message length
	mov ecx,msg	; message to write
	mov ebx,1	; file descriptor(stdout)
	mov eax,4	; system call number(sys_write)
	int 0x80	; call kernel

	mov eax,1	; system call number(sys)
	int 0x80	; call kernel

section .data
msg db 'Hello, world!', 0xa	;string to be printed
len equ $ - msg			;length of the string

```

在NASM中编译和链接程序

```shell
nasm -f elf hello.asm
# 链接目标文件
ld -m elf_i386 -s -o hello hello.o
```



# 汇编语言 内存段

## 内存段

如果将section 关键字替换为segment，也会得到相同的结果。

```nasm
segment .text      ;code segment
   global _start    ;must be declared for linker 
      
_start:            ;tell linker entry point
   mov edx,len     ;message length
   mov ecx,msg     ;message to write
   mov ebx,1       ;file descriptor (stdout)
   mov eax,4       ;system call number (sys_write)
   int 0x80        ;call kernel

   mov eax,1       ;system call number (sys_exit)
   int 0x80        ;call kernel

segment .data      ;data segment
msg     db 'Hello, world!',0xa   ;our dear string
len     equ     $ - msg          ;length of our dear string
```

## 内存段

分段存储器模型将系统存储器分为独立的分段组，这些分段由位于分段寄存器中的指针引用。每个段用于包含特定类型的数据。一个段用于包含指令代码，另一段用于存储数据元素，第三段保留程序堆栈。

* 数据段 由.data段和.bss段表示。.data节用于声明存储区，在该存储区中为程序存储了数据元素。声明数据元素后，无法扩展此部分，并且在整个程序中他保持静态。.bss部分也是一个静态内存部分，它包含缓冲区，供稍后在程序中声明的数据使用。这个缓冲区内存是零填充的
* 代码段 由.text部分表示。这在内存中定义了一个存储指令代码的区域。这也是一个固定区域
* 堆栈 该段包含传递给程序中的函数和过程的数据值


# 寄存器

## 寄存器

处理器操作主要涉及到处理数据。该数据可以存储在存储器中并从其访问。从存储器中读取数据中将数据存储到存储器中会减慢处理器的速度，因为这涉及到通过控制总线发送数据请求并进入存储器存储单元并通过同意通道获取数据的复杂过程。

为了加速处理器的运行，处理器包括一些内存处理器存储位置，称为寄存器。寄存器存储要处理的数据元素，而不必访问存储器。处理器芯片中内置了数量有限的寄存器


## 处理器寄存器

IA-32体系结构中有10个32位和6个16为处理器寄存器。寄存器分三类

* 通用寄存器
* 控制寄存器
* 段寄存器


通用寄存器分为以下几类

* 数据寄存器
* 指针寄存器
* 索引寄存器

// todo 有个寄存器不知道叫啥


四个32位数据寄存器用于算术，用于逻辑和其他操作。

完整的32位寄存器：EAX，EBX，ECX，EDX。下半部分的32位寄存器可用作四个16位寄存器：AX，BX，CX，DX。四个16位寄存器的上半部分和下半部分可以用作八个8位寄存器：AH，BH，CH，DH，AL，BL，CL，DL


* AX主要的累加器。用于输出/输入和绝大多数算术指令
* BX被称作基址寄存器，因为它可以用于索引寻址
* CX被称作计数寄存器，因为ECX，CX寄存器在迭代操作中存储循环计数
* DX被称作数据寄存器。它也用于输入/输出操作。他还与AX寄存器以及DX一起使用，用于涉及大数值的乘法和除法运算


## 指针寄存器

指针寄存器是32位EIP，ESP和EBP寄存器以及相应的16位右部分IP，SP和BP。指针寄存器分为三类

* 指令指针（IP）16位IP寄存器存储要执行的下一条指令的偏移地址。与CS寄存器
* 堆栈指针（SP）16位SP寄存器提供程序堆栈内的偏移值。与SS寄存器（SS:SP）关联的SP是指程序堆栈中数据或地址的当前位置。
* 基本指针（BP）16位BP寄存器主要帮助参考传递给子进程的参数变量。SS寄存器中的地址与BP中的偏移量相结合，以获取参数的位置。BP也可以与DI和SI组合用作特殊寻址的基址寄存器。

## 索引寄存器

32位索引寄存器ESI和EDI及最右边的16位部分。SI和DI用于索引寻址，有时用于加法和减法。有两组索引指针

* 源索引（SI）用作字符串操作的源索引
* 目的索引（DI）用作字符串操作的目标索引


## 控制寄存器

将32位指令指针寄存器的32位标志寄存器组合起来称为控制寄存器。许多指令涉及比较和数学计算，并更改标志的状态，而其他一些条件指令则测试这些状态标志的值，将控制流带到其他位置


通用标志位是：

* 溢出标志（OF）
* 方向标志（DF）
* 中断标志（IF）
* 陷阱标志（TF）
* 符号标志（ZF）
* 零标志（ZF）
* 辅助进位标志（AF）
* 奇偶校验标志（PF）
* 进位标志（CF）


## 段寄存器

段是程序中定义的


# 内存复制

# 堆栈指令


# 汇编如何写函数


# 堆栈传参


# 堆栈平衡


参考文档: 
[简明 x86 汇编指南](https://arthurchiao.art/blog/x86-asm-guide-zh/)
[汇编基础语法 菜鸟学院](https://cainiaoya.com/assemblylanguage/assembly-language-jiaocheng.html)