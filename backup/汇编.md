# 基本语法

汇编程序可以分为三个段

* data段
* bss段
* text段

## data段

数据段被用于声明初始化的数据或常数。此数据在运行时不会更改。可以在段中声明各种常用值，文件名或缓冲区大小等。

```nasm
section .data
```

## bss段

在bss声明变量。

```nasm
section .bss


```

## text段

代码段被用于保持实际的代码。该段必须以全集声明_start开头，该声明告诉内核程序从何处开始执行。

```nasm
section .test
    global _start
_start:
```

## 注释

汇编语言注释以分号(;)开头。它可以包含任何可打印字符，包括空格。它可以单独出现在一行上。

```nasm
;该程序在屏幕上显示一条信息
```

或者，与指令在同一行上。

```nasm
add eax, ebx ;加上ebx的值到eax
```

## 汇编语言声明

汇编语言程序包含三种类型的语句

* 可执行指令或说明
* 汇编程序指令或伪操作
* 宏

可执行指令或简单的指令告诉处理器做什么。每个指令由一个操作码组成。每个可执行指令生成一个机器语言指令。该汇编指令或位操作讲述装配过程中的各方面的汇编。这些是不可执行的，不会生成机器语言指令。宏是一种代码替换机制。

## 汇编语言语句的语法

汇编语言语句每行输入一个语句。每个语句遵循一下格式

```nasm
[label] mnemonic [operands] [;comment]
```

基本命令包括两段，第一段是要执行的指令（或助记符）的名称，第二段是命令的操作数或参数。以下是一些典型汇编语句的示例

```nasm
inc count         ; 增加内存变量count
mov total, 48     ; 将值48转移到内存变量total
add ah,bh         ; 将寄存器BH内容添加到ah寄存器
and mask1, 128    ; 对变量mask1 和 128执行and操作

add marks, 10     ; 将10加到变量marks
mov al, 10        ; 将值10传送到al寄存器
```

## 汇编语言的Hello World 程序

```nasm
section .text
	global _start
_start:
	mov edx,len	; message length
	mov ecx,msg	; message to write
	mov ebx,1	; file descriptor(stdout)
	mov eax,4	; system call number(sys_write)
	int 0x80	; call kernel

	mov eax,1	; system call number(sys)
	int 0x80	; call kernel

section .data
msg db 'Hello, world!', 0xa	;string to be printed
len equ $ - msg			;length of the string

```

在NASM中编译和链接程序

```shell
nasm -f elf hello.asm
# 链接目标文件
ld -m elf_i386 -s -o hello hello.o
```

# 汇编语言 内存段

## 内存段

如果将section 关键字替换为segment，也会得到相同的结果。

```nasm
segment .text      ;code segment
   global _start    ;must be declared for linker 
  
_start:            ;tell linker entry point
   mov edx,len     ;message length
   mov ecx,msg     ;message to write
   mov ebx,1       ;file descriptor (stdout)
   mov eax,4       ;system call number (sys_write)
   int 0x80        ;call kernel

   mov eax,1       ;system call number (sys_exit)
   int 0x80        ;call kernel

segment .data      ;data segment
msg     db 'Hello, world!',0xa   ;our dear string
len     equ     $ - msg          ;length of our dear string
```

## 内存段

分段存储器模型将系统存储器分为独立的分段组，这些分段由位于分段寄存器中的指针引用。每个段用于包含特定类型的数据。一个段用于包含指令代码，另一段用于存储数据元素，第三段保留程序堆栈。

* 数据段 由.data段和.bss段表示。.data节用于声明存储区，在该存储区中为程序存储了数据元素。声明数据元素后，无法扩展此部分，并且在整个程序中他保持静态。.bss部分也是一个静态内存部分，它包含缓冲区，供稍后在程序中声明的数据使用。这个缓冲区内存是零填充的
* 代码段 由.text部分表示。这在内存中定义了一个存储指令代码的区域。这也是一个固定区域
* 堆栈 该段包含传递给程序中的函数和过程的数据值

# 寄存器

## 寄存器

处理器操作主要涉及到处理数据。该数据可以存储在存储器中并从其访问。从存储器中读取数据中将数据存储到存储器中会减慢处理器的速度，因为这涉及到通过控制总线发送数据请求并进入存储器存储单元并通过同意通道获取数据的复杂过程。

为了加速处理器的运行，处理器包括一些内存处理器存储位置，称为寄存器。寄存器存储要处理的数据元素，而不必访问存储器。处理器芯片中内置了数量有限的寄存器

## 处理器寄存器

IA-32体系结构中有10个32位和6个16为处理器寄存器。寄存器分三类

* 通用寄存器
* 控制寄存器
* 段寄存器

通用寄存器分为以下几类

* 数据寄存器
* 指针寄存器
* 索引寄存器

// todo 有个寄存器不知道叫啥

四个32位数据寄存器用于算术，用于逻辑和其他操作。

完整的32位寄存器：EAX，EBX，ECX，EDX。下半部分的32位寄存器可用作四个16位寄存器：AX，BX，CX，DX。四个16位寄存器的上半部分和下半部分可以用作八个8位寄存器：AH，BH，CH，DH，AL，BL，CL，DL

* AX主要的累加器。用于输出/输入和绝大多数算术指令
* BX被称作基址寄存器，因为它可以用于索引寻址
* CX被称作计数寄存器，因为ECX，CX寄存器在迭代操作中存储循环计数
* DX被称作数据寄存器。它也用于输入/输出操作。他还与AX寄存器以及DX一起使用，用于涉及大数值的乘法和除法运算

## 指针寄存器

指针寄存器是32位EIP，ESP和EBP寄存器以及相应的16位右部分IP，SP和BP。指针寄存器分为三类

* 指令指针（IP）16位IP寄存器存储要执行的下一条指令的偏移地址。与CS寄存器
* 堆栈指针（SP）16位SP寄存器提供程序堆栈内的偏移值。与SS寄存器（SS:SP）关联的SP是指程序堆栈中数据或地址的当前位置。
* 基本指针（BP）16位BP寄存器主要帮助参考传递给子进程的参数变量。SS寄存器中的地址与BP中的偏移量相结合，以获取参数的位置。BP也可以与DI和SI组合用作特殊寻址的基址寄存器。

## 索引寄存器

32位索引寄存器ESI和EDI及最右边的16位部分。SI和DI用于索引寻址，有时用于加法和减法。有两组索引指针

* 源索引（SI）用作字符串操作的源索引
* 目的索引（DI）用作字符串操作的目标索引

## 控制寄存器

将32位指令指针寄存器的32位标志寄存器组合起来称为控制寄存器。许多指令涉及比较和数学计算，并更改标志的状态，而其他一些条件指令则测试这些状态标志的值，将控制流带到其他位置

通用标志位是：

* 溢出标志（OF）指示有符号算术运算后数据的高阶位（最左位）的溢出。
* 方向标志（DF）它确定向左或向右移动或比较字符串数据的方向。DF值为0时，字符串操作为从左向右的方向；当DF值为1时，字符串操作为从右至左的方向
* 中断标志（IF）确定是否忽略或处理外部中断（如键盘中断输入等）。当值为0时，它禁用外部中断，当值为1时，使能中断
* 陷阱标志（TF）允许在单步模式下设置处理器的操作。我们使用的DEBUG程序设置了陷阱标志，因此我们可以一次逐步执行一条指令。
* 符号标志（SF）显示算术运算结果符号。根据算术运算后数据项的符号设置此标志。该符号由最左位的高位指示。正结果将SF的值清除为0，负结果将其设置为1.
* 零标志（ZF）指示算术或比较运算的结果。非零结果将零标志清零，零结果将其清零
* 辅助进位标志（AF）包含经过算术运算后从位3到位4的进位；用于专业算术。当1字节算术运算引起从第3位到第4位的进位时，将设置AF。
* 奇偶校验标志（PF）指示从算术运算获得的结果中1位的总数。偶数个1位将奇数校验标志位清为0，奇数个1位将将奇偶校验标志清为1。
* 进位标志（CF）在算术运算后，它包含一个高位（最左边）的进位。它还存储移位或旋转操作的最后一位的内容。

## 段寄存器

段是程序中定义的特定区域，用于包含数据，代码和堆栈。有三个部分

* 代码段（CS） 它包含所有要执行的指令。16位代码段寄存器或CS寄存器存储代码段的起始地址。
* 数据段（DS） 它包含数据、常量和工作区。16位数据段寄存器或DS寄存器存储数据段的起始地址。
* 堆栈段（SS） 它包含数据或过程或子进程的返回地址。它被实现为“堆栈”数据结构。堆栈段寄存器或SS寄存器存储堆栈的起始地址。

除了DS，CS，SS寄存器外，还有其他段寄存器-ES（额外段），FS和GS，他们提供了用于存储数据的其他段。在汇编语言中，程序需要访问存储器的位置。段中的所有存储位置都相对于段的起始地址。段的其实地址可以时16或者16进制的整数，因此，所有此类存储地址中最右边的十六进制数字为0，通常不存储在段寄存器中。段寄存器存储段的起始地址。为了获得数据或指令在段中的确切位置，需要一个偏移值（或者位移）。为了引用段中的任何存储位置，处理器将段寄存器中的段地址与该位置的偏移值进行组合。

```nasm
section .text
    global _start

_start:
    mov edx, len ; message length
    mov ecx, msg ; message to write
    mov ebx, 1   ; file descriptor (stdout)
    mov eax, 4   ; system call number (sys_write)
    int 0x80     ; call kernel

    mov edx, 9
    mov ecx, s2
    mov ebx, 1
    mov eax, 4
    int 0x80

    mov eax, 1    ; system call number (sys_exit)
    int 0x80      ; call kernel



section .data
msg db 'Displaying 9 stars', 0xa
len equ $ - msg
s2 times 9 db '*'
```

# 系统调用

## 系统调用

是用户空间和内核空间之间接口的API。我们已经使用了系统调用。sys_write和sys_exit分别用于写入屏幕和退出程序

# Linux系统调用

可以通过以下步骤使用linux系统调用

* 将系统呼叫号放入EAX寄存器中
* 将参数保存到系统调用中的寄存器EBX、ECX等中
* 调用相关的中断（80h）
* 结果通常在EAX寄存器中返回

用于存储系统调用参数的寄存器有六个，分别是EBX、EDX、ESI、EDI和EBP，这些寄存器采用从EBX寄存器开始的连续参数。如果有六个以上的自变量，则第一个自变量的存储位置将存储在EBX寄存器中。

```nasm
mov eax,1
int 0x80
```

sys_write的使用

```nasm
mov ebx,4
mov ecx,msg
mov ebx,1
mov eax,4
int 0x80
```

所有系统调用及其编号都列在/usr/include/asm/unistd.h中

从键盘读取一个数字并将其显示在屏幕上

```nasm

section .data
	userMsg db 'Please enter a number:'
	lenUserMsg equ $-userMsg
	dispMsg db 'You have entered:'
	lenDispMsg equ $-dispMsg

section .bss
	num resb 5

section .txt
	global _start

_start:
	mov eax,4
	mov ebx,1
	mov ecx,userMsg
	mov edx,lenUserMsg
	int 0x80

	mov eax,3
	mov ebx,0
	mov ecx,num
	mov edx,5
	int 0x80

	mov eax,4
	mov ebx,1
	mov ecx,dispMsg
	mov edx,lenDispMsg
	int 0x80

	mov eax,4
	mov ebx,1
	mov ecx,num
	mov edx,5
	int 0x80

	mov eax,1
	mov ebx,0
	int 0x80
```

# 寻址模式

## 寻址模式

大多数汇编语言指令都需要处理操作数。操作数地址提供了要处理的数据存储的位置。有些指令不需要操作数，而另一些指令则需要一个，两个或者三个操作数。当一条指令需要两个操作数时，第一个操作数通常时目的地，他在寄存器或存储器位置中包含数据，第二个操作数是源。源包含要传递的数据（立即寻址）或数据的地址（在寄存器或者存储器中）。通常，操作后源数据保持不变。

寻址的三种基本模式是

* 寄存器寻址
* 立即寻址
* 内存寻址

## 寄存器寻址

在这种寻址模式下，寄存器包含操作数。根据指令，寄存器可以是第一个操作数，第二个操作数或者两者。

```nasm
mov dx,tax_rate ;寄存器是第一个操作数
mov count,cx	;寄存器是第二个操作数
mov eax,edx	;两个操作数都是寄存器
```

由于寄存器之间的数据处理不涉及内存，因此可以最快的处理数据

## 立即寻址

立即数操作数具有常量值或表达式。当具有两个操作数的指令使用立即寻址时，第二个操作数可以是寄存器或者存储器位置，而第二个操作数是立即数。第一个操作数定义数据的长度

```nasm
BYTE_VALUE DB 150 ;一个字节值被定义
WORD_VALUE DW 300 ;一个字节值被定义
ADD BYTE_VALUE, 65;BYTE_VALUE加一个立即操作数65
MOV AX,45H	  ;立即常数45H转移到AX
```

## 直接内存寻址

在内存寻址模式下指定操作数时，通常需要直接访问主存储器，通常时数据段。这种寻址方式导致数据处理变慢。为了找到数据在内存中的确切位置，我们需要短期是地址（通常在DS寄存器中找到）和偏移量。因此偏移量也称为有效地址。在直接寻址模式下，偏移量值直接作为指令的一部分指定，通常由变量名指示。汇编器计算偏移值并维护一个符号表，该表存储程序中使用的所有变量的偏移值。直接存储寻址中，一个操作数引用一个存储器位置，另一个操作数引用一个寄存器

```nasm
ADD BYTE_VALUE,DL ;将寄存器添加到存储位置
MOV BX,WORD_VALUE ;将内存中的操作数添加到寄存器中
```

## 直接偏移寻址

该模式使用算术运算符修改地址

```nasm
BYTE_TABLE DB 14,15,22,45  ;字节表
WORD_TABLE 134,345,564,123 ;字表
```

以下操作数将数据从内存中的表访问到寄存器中

```nasm
mov cl,BYTE_TABLE[2]
mov cl,BYTE_TABLE + 2 
mov cx,WORD_TABLE[3]
mov cx,WORD_TABLE + 3
```

## 间接内存寻址

此寻址模式利用计算机的Segmeng：Offset寻址功能功能。通常，在方括号内百年好的基址寄存器EBX，EBP（或BX，BP）和索引寄存器（DI，SI）用于内存引用

间接寻址通常用于包含多个元素（如数组）的变量。阵列的其实地址存储在EBX寄存器中。

```nasm
my_table times 10 DW 0  ; 分配10个字（2个字节），每个字都初始化为0
mov ebx,[my_table]	; ebx中my_table的有效地址
mov [ebx],110		; my_table[0] = 110
add ebx,2		; ebx = ebx + 2
mov [ebx],123		; my_table[1] = 123
```

## MOV 指令

该指令用于将数据从一个存储空间移动到另一个存储空间。mov指令采用两个操作数。

```
MOV destination,source
```

MOV 指令可能具有以下五种形式之一

```nasm
MOV 寄存器, 寄存器
MOV 寄存器, 立即数
MOV 寄存器, 内存
MOV 内存, 立即数
MOV 内存, 寄存器

```

**注意**

* MOV操作数中的两个操作数应该具有相同的大小
* 源操作数的值保持不变

以下命令会引起歧义：

```nasm
mov ebx, [my_table]
mov [ebx], 110
```

目前不清楚要移动等于110的字节等效值还是等效于字的字符。在这种情况下使用类型说明符时明智的。

| 类型说明符 | 寻址字节 |
| ---------- | -------- |
| BYTE       | 1        |
| WORD       | 2        |
| DWORD      | 4        |
| QWORD      | 8        |
| TBYTE      | 10       |

```nasm


section .data
name db 'Alex MO'
nameLength equ $-name

newLine db '\n'
newLineLength equ $-newLine

section .text
	global _start

_start:
	mov edx,nameLength
	mov ecx,name
	mov ebx,1
	mov eax,4
	int 0x80

	;输出\n无法实现换行
	;mov edx,newLineLength 
	;mov ecx,newLine 
	;mov ebx,1
	;mov eax,4
	;int 0x80

	mov [name], dword 'Feng'

	mov edx,nameLength
	mov ecx,name
	mov ebx,1
	mov eax,4
	int 0x80

	mov eax,1
	mov ebx,0
	int 80h
```

# 变量

## 变量

nasm提供了各种定义指令来为变量保留存储空间。define assembler指令用于分配存储空间。它可以用于保留以及初始化一个或多个字节。

## 为初始数据分配存储空间

初始化数据的存储分配语句的语法为

```nasm
[variable-name] define-directive initial-value [,initial-value]
```

其中，变量名是每个存储空间的标识符。汇编器为数据段中定义的每个变量名称关联一个偏移值。

define指令有五种基本形式

| 指令 | 目的         | 存储空间     |
| ---- | ------------ | ------------ |
| DB   | 定义字节     | 分配一个字节 |
| DW   | 定义字       | 分配两个字节 |
| DD   | 定义双字     | 分配四个字节 |
| DQ   | 定义四字     | 分配八个字节 |
| DT   | 定义十个字节 | 分配十个字节 |

以下时一些使用define指令的示例

```nasm
choice db  'y'
number dw 12345
neg_number dw -12345
big_number dq 123456789
real_number1 dd 1.234
real_number2 dq 123.456
```

**注意**

* 字符的每个字节均以十六进制形式存储为ASCII值
* 每个十进制值都将自动转换为其等效的16位二进制数，并以十六进制数形式存储
* 处理器使用小尾数字节顺序
* **负数将转换为其2的补码表示形式**
* 短浮点数和长浮点数分别使用32位和64位表示

define指令的使用

```nasm
section .text
	global _start

_start:
	mov edx,1
	mov ecx,choice
	mov ebx,1
	mov eax,4
	int 80h

	mov eax,1
	mov ebx,1
	int 80h

section .data
choice DB 'y'
```

## 为未初始化的数据分配存储空间

reserve指令用于为未初始化的数据保留空间。reserve指令采用单个操作数，该操作数指定要保留的空间单位数。每个define指令都有一个相关的reserve指令。

保留指令有五种基本形式

| 指令 | 目的         |
| ---- | ------------ |
| RESB | 保留一个字节 |
| RESW | 保留字       |
| RESD | 保留双字     |
| RESQ | 保留四字     |
| REST | 保留十个字   |

## 多种定义

一个程序中可以有多个数据定义语句。例如

```nasm
choice DB 'y'
number1 DW 123456
number2 DD 123456789
```

## 多重初始化

TIMES 指令允许多次初始化为相同的值。下面语句定义一个大小为9的标记数组并将其初始化为零

```nasm
marks TIMES 9 DW 0
```

TIMES指令在定义数组和表时很有用

```nasm
section .text
	global _start
_start:
	mov edx,9
	mov ecx,stars
	mov ebx,1
	mov eax,4
	int 80h

	mov eax,1
	mov ebx,0
	int 80h

section .data
starts times 9 db '*'
```

# 常量

## 常量

nasm提供了几个定义常量的指令。之前我们已经使用了EQU指令，下面将特别讨论几个

* EQU
* %assign
* %define

## EQU指令

EQU指令用于定义常量。EQU指令的语法如下

```nasm
constant_name equ expression

total_students equ 50
length equ 20
width equ 10
area equ length * width
```

以上代码段将area定义为200

```nasm
SYS_EXIT equ 1
SYS_WRITE equ 4
SYS_READ equ 3
STDIN equ 0
STDOUT equ 1


section .data
msg_1 db 'Hello, programers!\n',0xA,0XD
length_1 equ $ - msg_1

msg_2 db 'Please input a number:',0XA,0XD
length_2 equ $ - msg_2

msg_3 db 'Read a number:'
length_3 equ $ - msg_3

section .bss
	num resb 5


section .text
	global _start

_start:
	mov edx,length_1
	mov ecx,msg_1
	mov ebx,STDOUT
	mov eax,SYS_WRITE
	int 80h

	mov edx,length_2 
	mov ecx,msg_2 
	mov ebx,STDOUT
	mov eax,SYS_WRITE
	int 80h

	mov edx,5
	mov ecx,num
	mov ebx,STDIN
	mov eax,SYS_READ
	int 0x80

	mov edx,length_3 
	mov ecx,msg_3 
	mov ebx,STDOUT
	mov eax,SYS_WRITE
	int 80h

	mov edx,4
	mov ecx,num
	mov ebx,STDOUT
	mov eax,SYS_WRITE
	int 80h

	mov ebx,0
	mov eax,SYS_EXIT
	int 80h
```

## %assign指令

在%assign指令可以用来定义数字常量像equ指令。该指令允许重新定义。

```asm
%assign total 10;定义常量total为10

%assign total 20;重新定义为20
```

**注意**

该指令区分大小写

## %define指令

在%define指令允许定义数值和字符串常量。类似于#define

```nasm
%define PTR [EBP+4]
```

该指令还允许重新定义，并且区分大小写。

# 算术指令

## INC指令

INC 指令用于将操作数加1.它可以对寄存器或内存中的单个操作数起作用

```asm
INC destination

INC EBX; 32位寄存器，自增1
INC DL; 8位寄存器 自增1

INC [count];变量count 自增1
```


## DEC指令

DEC指令用于将操作数减一。它可以对在寄存器或内存中的单个操作数起作用。

```nasm
DEC destination
```

操作数目的可以是8位，16位或32位操作数


```nasm
segment .data
	count dw 0
	value db 15

segment .text
	inc [count]
	dec [value]

	mov ebx,count
	inc word [ebx]

	mov esi, value
	dec byte [esi]
```


## ADD和SUB指令

ADD和SUB指令用于对字节，字和双字大小的二进制数进行简单的加/减，即分别用于添加或减去8位、16位、和32位操作数

```nasm
ADD/SUB destination, source
```

ADD/SUB指令可以用于

* 寄存器 to 寄存器
* 内存 to 寄存器
* 寄存器 to 内存
* 寄存器 to 常量数据
* 内存 to 常量数据

但是，像其他指令一样，使用ADD/SUB指令也无法进行存储器到存储器的操作。ADD或SUB操作设置或清除溢出和进位标志

下面的示例将要求用于输入两位数字，分别将这些数字存储在EAX和EBX寄存器中，将这些值相加，将结果存储在res存储位置中，最后显示显示结果


```nasm
; 为什么equ 指令可以不在section .data中

SYS_EXIT equ 1
SYS_READ equ 3
SYS_WRITE equ 4
STDIN equ 0
STDOUT equ 1

segment .data
   msg1 db "Enter a digit ", 0xA,0xD 
   len1 equ $- msg1 

   msg2 db "Please enter a second digit", 0xA,0xD 
   len2 equ $- msg2 

   msg3 db "The sum is: "
   len3 equ $- msg3

segment .bss
   num1 resb 2 
   num2 resb 2 
   res resb 1 

section .text 
	global _start



_start:
   mov eax, SYS_WRITE   
   mov ebx, STDOUT   
   mov ecx, msg1   
   mov edx, len1 
   int 0x80  

   mov eax, SYS_READ 
   mov ebx, STDIN  
   mov ecx, num1 
   mov edx, 2
   int 0x80  

   mov eax, SYS_WRITE  
   mov ebx, STDOUT   
   mov ecx, msg2  
   mov edx, len2   
   int 0x80

   mov eax, SYS_READ  
   mov ebx, STDIN  
   mov ecx, num2 
   mov edx, 2
   int 0x80  

   mov eax, SYS_WRITE   
   mov ebx, STDOUT   
   mov ecx, msg3  
   mov edx, len3   
   int 0x80

   ; moving the first number to eax register and second number to ebx
   ; and subtracting ascii '0' to convert it into a decimal number
  
   mov eax, [num1]
   sub eax, '0'
  
   mov ebx, [num2]
   sub ebx, '0'

   ; add eax and ebx
   add eax, ebx
   ; add '0' to to convert the sum from decimal to ASCII
   add eax, '0'

   ; storing the sum in memory location res
   mov [res], eax

   ; print the sum 
   mov eax, SYS_WRITE  
   mov ebx, STDOUT
   mov ecx, res   
   mov edx, 1  
   int 0x80
exit:
   mov eax,SYS_EXIT
   xor ebx,ebx
   int 80h
```


## MUL/IMUL指令

有两条指令用于将二进制数据相乘。MUL（乘法）指令处理未签名的数据，而IMUL（整数乘法）则处理签名数据。两条指令影响进位和溢出标志

MUL/IMUL指令的语法如下：

```nasm
MUL/IMUL multiplier
```

在这种情况下，被乘数都将在一个累加器中，具体取决于被乘数和乘数的大小，并更具操作数的大小，生成的乘积还将存储在两个寄存器中。以下部分说明了三种不同情况下的MUL指令

| 情况               | 描述                                                                                                                                                                                                                                                           |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 当两个字节相乘时   | 被乘数在AL寄存器中，而乘数在存储器或<br />另一个寄存器中为一个字节。此情况使用AX。<br />乘积的高8位存储在AH中，低8位存储在AL中。                                                                                                                               |
| 当两个单字相乘时   | 被乘数应位于AX寄存器中，并且乘数是内存<br />或其他寄存器中的一个字。列如，对于MUL DX之类的指令，<br />必须将乘数存储在DX中，将被乘数存储在AX中。结果乘积是一个双字。<br />将需要两个寄存器。高阶（最左侧）部分存储在DX中，而低阶（最右侧）<br />部分存储在AX中 |
| 当两个双字值相乘时 | 当两个双字值相乘时，被乘数应位于EAX中，并且该乘数是存储<br />在存储器或另一个存储器中的双字值。生成的乘积存储在EDX:EAX<br />寄存器中，即，高32位存储在EDX寄存器中，低32位存储在EAX寄存器中                                                                     |


```nasm
MOV AL, 10
MOV DL, 25
MUL DL

MOV DL,0FFH
MOV AL,0BEH
IMUL DL

```








# 内存复制

# 堆栈指令

# 汇编如何写函数

# 堆栈传参

# 堆栈平衡

参考文档:
[简明 x86 汇编指南](https://arthurchiao.art/blog/x86-asm-guide-zh/)
[汇编基础语法 菜鸟学院](https://cainiaoya.com/assemblylanguage/assembly-language-jiaocheng.html)
