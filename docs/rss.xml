<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Paimon's blog</title><link>https://paimonlee.github.io/paimon.github.io</link><description>Life is a fucking movie!人生如戲啊，靚仔！</description><copyright>Paimon's blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/38132146</url><title>avatar</title><link>https://paimonlee.github.io/paimon.github.io</link></image><lastBuildDate>Wed, 26 Jun 2024 11:11:53 +0000</lastBuildDate><managingEditor>Paimon's blog</managingEditor><ttl>60</ttl><webMaster>Paimon's blog</webMaster><item><title>【Shell】启动子进程</title><link>https://paimonlee.github.io/paimon.github.io/post/%E3%80%90Shell%E3%80%91-qi-dong-zi-jin-cheng.html</link><description>source 和 . 不启用新的shell，在当前shell中执行，设定的局部变量在执行完命令后仍然有效。</description><guid isPermaLink="true">https://paimonlee.github.io/paimon.github.io/post/%E3%80%90Shell%E3%80%91-qi-dong-zi-jin-cheng.html</guid><pubDate>Wed, 26 Jun 2024 11:08:35 +0000</pubDate></item><item><title>【gcc】gcc常用命令</title><link>https://paimonlee.github.io/paimon.github.io/post/%E3%80%90gcc%E3%80%91gcc-chang-yong-ming-ling.html</link><description># 基本命令&#13;
gcc的基本语法是&#13;
```shell&#13;
gcc [options] [filename]&#13;
```&#13;
&#13;
其中options表示参数，[filename]表示相关文件的名称&#13;
&#13;
## -x language filename&#13;
设定文件的语言，使后缀名无效，对之后的后缀名做同样的处理，语言类型有c,objective-c,c-header,c++,cpp-output,assembler和assembler-with-cpp&#13;
```shell&#13;
gcc -x c hello.pig&#13;
```&#13;
&#13;
## -x none file&#13;
关闭上一个选项，也就是让gcc根据文件名后缀，自动识别文件类型&#13;
```shell&#13;
gcc -x c hello.pig -x none hello2.c&#13;
```&#13;
&#13;
## -c&#13;
只激活预处理，编译和汇编，也就是他只把程序做成obj文件,下面命令将会生成.o的obj文件&#13;
```shell&#13;
gcc -c hello.c&#13;
```&#13;
&#13;
## -S &#13;
只激活预处理和编译，就是把文件编译成汇编代码，下面命令将会生成汇编代码，可以使用文本编辑器查看&#13;
```shell&#13;
gcc -S hello.c&#13;
```&#13;
&#13;
## -E&#13;
只激活预处理,这个命令不生成文件，需要将输出重定向到一个文件内&#13;
```shell&#13;
gcc -E hello.c &gt; pianoapan.txt&#13;
gcc -E hello.c | more&#13;
```&#13;
## -o&#13;
指定目标文件名称，默认的名字是a.out&#13;
```shell&#13;
gcc -o hello hello.c&#13;
gcc -o hello.asm -S hello.c&#13;
```&#13;
&#13;
## -pipe&#13;
使用管道替代编译中的临时文件，在使用非gnu汇编工具的时候，可能有问题&#13;
```shell&#13;
gcc -pipe -o hello hello.c&#13;
```&#13;
&#13;
## -ansi&#13;
关闭gnu c中与ansi c不兼容的特性，只激活ansi c的专有特性（包括asm inline typeof关键字，以及unix，vax 等预处理宏)&#13;
&#13;
## -fno-asm&#13;
实现-ansi选项的部分功能，禁止asm，inline何typeof用作关键字&#13;
&#13;
## fno-strict-prototype&#13;
只对g++起作用，使用这个选项，g++ 将对不带参数的函数，都认为是没有显示的对参数的个数和类型说明，而不是没有参数。</description><guid isPermaLink="true">https://paimonlee.github.io/paimon.github.io/post/%E3%80%90gcc%E3%80%91gcc-chang-yong-ming-ling.html</guid><pubDate>Tue, 25 Jun 2024 14:49:54 +0000</pubDate></item><item><title>【Git】fetch</title><link>https://paimonlee.github.io/paimon.github.io/post/%E3%80%90Git%E3%80%91fetch.html</link><description># 更新同步远程分支情况&#13;
```&#13;
# 拉取远程修改，不删除分支&#13;
git fetch&#13;
# 拉取远程分支，删除已经被删除的远程分支&#13;
git fetch -p/--prune&#13;
```。</description><guid isPermaLink="true">https://paimonlee.github.io/paimon.github.io/post/%E3%80%90Git%E3%80%91fetch.html</guid><pubDate>Mon, 24 Jun 2024 12:28:30 +0000</pubDate></item><item><title>【Shell命令】sort命令</title><link>https://paimonlee.github.io/paimon.github.io/post/%E3%80%90Shell-ming-ling-%E3%80%91sort-ming-ling.html</link><description>sort命令是Unix系统强大的文件文本排序工具&#13;
## 基本用法&#13;
```shell&#13;
# 按照字母顺序排序file.txt的行，并输出到标准输出。</description><guid isPermaLink="true">https://paimonlee.github.io/paimon.github.io/post/%E3%80%90Shell-ming-ling-%E3%80%91sort-ming-ling.html</guid><pubDate>Mon, 24 Jun 2024 12:26:14 +0000</pubDate></item><item><title>汇编</title><link>https://paimonlee.github.io/paimon.github.io/post/hui-bian.html</link><description># 汇编指令&#13;
&#13;
&#13;
# 内存复制&#13;
&#13;
# 堆栈指令&#13;
&#13;
&#13;
# 汇编如何写函数&#13;
&#13;
&#13;
# 堆栈传参&#13;
&#13;
&#13;
# 堆栈平衡&#13;
&#13;
&#13;
参考文档: &#13;
[简明 x86 汇编指南](https://arthurchiao.art/blog/x86-asm-guide-zh/)。</description><guid isPermaLink="true">https://paimonlee.github.io/paimon.github.io/post/hui-bian.html</guid><pubDate>Sun, 23 Jun 2024 07:38:26 +0000</pubDate></item><item><title>寄存器名称</title><link>https://paimonlee.github.io/paimon.github.io/post/ji-cun-qi-ming-cheng.html</link><description># 不同的寄存器&#13;
&#13;
```&#13;
32位    16位    8位&#13;
EAX     AX      AL&#13;
ECX     CX      CL&#13;
EDX     DX      DL&#13;
EBX     BX      BL&#13;
ESP     SP      AH&#13;
ENP     NP      CH&#13;
ESI     SI      DH&#13;
EDI     DI      BH&#13;
```&#13;
L高八位&#13;
H低八位&#13;
&#13;
# 32位计算机寻址能力&#13;
1Byte(字节) = 8bit(比特位，简称比特)&#13;
&#13;
1KB = 1024B = 2^10 B&#13;
&#13;
1MB = 1024KB = 2^20 B&#13;
&#13;
所以1个字节的某一状态可由8位数(二进制，只能是0或1)组成：&#13;
&#13;
如0 0 0 0 | 0 0 0 1 这8位数就代表1字节的一种状态,&#13;
8位二进制数总共能组合出2^8种状态 即可以表示2^8 B&#13;
&#13;
同样的，16位操作系统的地址宽度为16位&#13;
&#13;
即0 0 0 0 | 0 0 0 0 | 0 0 0 0 | 0 0 0 1,这16位数就代表2个字节(1Word，即1个字)的一种状态，16位二进制数总共能组合出2^8 ∗ 2^8 = 2^16 能够表示 2^16 个bit&#13;
所以能够寻址的内存是 2^16 B = 1024 B&#13;
。</description><guid isPermaLink="true">https://paimonlee.github.io/paimon.github.io/post/ji-cun-qi-ming-cheng.html</guid><pubDate>Sun, 23 Jun 2024 07:38:08 +0000</pubDate></item><item><title>位运算实现加减乘除</title><link>https://paimonlee.github.io/paimon.github.io/post/wei-yun-suan-shi-xian-jia-jian-cheng-chu.html</link><description># 位运算实现加减乘除&#13;
## 加法&#13;
&#13;
```&#13;
4 + 5&#13;
0000 0100 + 0000 0101&#13;
&#13;
第一步，异或，如果不考虑进位，异或就可以直接出结果&#13;
0000 0100&#13;
0000 0101&#13;
--------------&#13;
0000 0001&#13;
&#13;
第二步，与运算（判断进位，如果与运算位0，则没有进位）&#13;
0000 0100&#13;
0000 0101&#13;
--------------&#13;
0000 0100&#13;
&#13;
第三步，将与运算的结果左移一位，0000 1000&#13;
&#13;
第四步，异或 将第一步和第三步的结果进行异或运算&#13;
0000 0001&#13;
0000 1000&#13;
------------------&#13;
0000 1001&#13;
&#13;
第五步，验算，将第一步和第三步的结果进行与运算，如果为0，&#13;
则第四步则为最终结果，如果不为0，则有进位，则与第四步结果异或&#13;
0000 0001&#13;
0000 1000&#13;
------------------&#13;
0000 0000&#13;
```&#13;
&#13;
伪代码&#13;
```&#13;
def add(a, b):&#13;
    c = a ^ b&#13;
    d = a &amp; b&#13;
    if d == 0:&#13;
        # 没有进位，直接返回结果&#13;
        return c&#13;
    else:&#13;
        d = d &lt;&lt; 1&#13;
        add(c, d)&#13;
```&#13;
&#13;
## 减法&#13;
4 - 5 = 4 + (-5)&#13;
0000 0100 + 1111 1011 (计算机中负数存储的是补码)&#13;
。</description><guid isPermaLink="true">https://paimonlee.github.io/paimon.github.io/post/wei-yun-suan-shi-xian-jia-jian-cheng-chu.html</guid><pubDate>Sat, 22 Jun 2024 14:48:26 +0000</pubDate></item><item><title>位运算</title><link>https://paimonlee.github.io/paimon.github.io/post/wei-yun-suan.html</link><description># 位运算&#13;
&#13;
## 与、或、异或、非&#13;
&#13;
### 与运算（and &amp;）&#13;
&#13;
```&#13;
1 0 1 1  1 1 0 0&#13;
0 1 1 1  0 0 0 0&#13;
                    and&#13;
-------------------------&#13;
0 0 1 1  0 0 0 0&#13;
```&#13;
&#13;
&#13;
### 或运算（or |）&#13;
```&#13;
1 0 1 1  1 1 0 0&#13;
0 1 1 1  0 0 0 0&#13;
                    or&#13;
-------------------------&#13;
1 1 1 1  1 1 0 0&#13;
```&#13;
&#13;
### 异或运算（xor ^）&#13;
&#13;
```&#13;
1 0 1 1  1 1 0 0&#13;
0 1 1 1  0 0 0 0&#13;
                    or&#13;
-------------------------&#13;
1 1 0 0  1 1 0 0&#13;
```&#13;
&#13;
### 非运算（单目运算符 not ~）&#13;
```&#13;
1 0 1 1  1 1 0 0&#13;
                    not&#13;
-------------------------&#13;
0 1 0 0  0 0 1 1&#13;
```&#13;
&#13;
## 位运算（移动位）&#13;
&#13;
### 左移（&lt;&lt;）&#13;
&#13;
```&#13;
0000 0001 所有二进制位全部向左移动若干位，高位丢弃，低位补零&#13;
0000 0010 &#13;
```&#13;
&#13;
### 右移（&gt;&gt;）&#13;
```&#13;
0000 0010 所有二进制位全部向右移动若干位，高位补零(或一，由符号位决定)，低位丢弃&#13;
0000 0001&#13;
```。</description><guid isPermaLink="true">https://paimonlee.github.io/paimon.github.io/post/wei-yun-suan.html</guid><pubDate>Sat, 22 Jun 2024 09:43:37 +0000</pubDate></item><item><title>原码、反码和补码</title><link>https://paimonlee.github.io/paimon.github.io/post/yuan-ma-%E3%80%81-fan-ma-he-bu-ma.html</link><description>原码：最高位符号位，其余对齐本身值即可&#13;
&#13;
反码（反码，反的是原码）：&#13;
    * 正数：反码和原码一致&#13;
    * 负数：符号位为1，其余位对原码取反&#13;
&#13;
补码（补码，补的就是反码）：&#13;
    * 正数：补码和原码一致&#13;
    * 负数：符号位为1，其余位反码+1&#13;
&#13;
```&#13;
7&#13;
原码：0 0 0 0  0 1 1 1&#13;
反码：0 0 0 0  0 1 1 1&#13;
补码：0 0 0 0  0 1 1 1&#13;
&#13;
-7&#13;
原码：1 0 0 0  0 1 1 1&#13;
反码：1 1 1 1  1 0 0 0 &#13;
补码：1 1 1 1  1 0 0 1&#13;
```。</description><guid isPermaLink="true">https://paimonlee.github.io/paimon.github.io/post/yuan-ma-%E3%80%81-fan-ma-he-bu-ma.html</guid><pubDate>Sat, 22 Jun 2024 07:36:24 +0000</pubDate></item><item><title>【Python】协程</title><link>https://paimonlee.github.io/paimon.github.io/post/%E3%80%90Python%E3%80%91-xie-cheng.html</link><description># 关键字&#13;
&#13;
async、await、asyncio&#13;
&#13;
# 运行一个协程&#13;
&#13;
```python&#13;
import asyncio&#13;
&#13;
async def main():&#13;
    print('hello')&#13;
    await asyncio.sleep(1)&#13;
    print('world')&#13;
&#13;
asyncio.run(main())&#13;
```&#13;
&#13;
要实际运行一个协程，asyncio 提供了一下几种机制：&#13;
&#13;
- asyncio.run()函数用来运行最高层级的入口点'main()'函数&#13;
  &#13;
- 对协程执行await。</description><guid isPermaLink="true">https://paimonlee.github.io/paimon.github.io/post/%E3%80%90Python%E3%80%91-xie-cheng.html</guid><pubDate>Thu, 20 Jun 2024 14:00:10 +0000</pubDate></item><item><title>【Git】stash</title><link>https://paimonlee.github.io/paimon.github.io/post/%E3%80%90Git%E3%80%91stash.html</link><description># 隐藏指定文件&#13;
一般情况下，暂时隐藏修改的命令是&#13;
```shell&#13;
# 使用上一个commit的信息&#13;
git stash&#13;
# 使用指定信息&#13;
git stash -m 'This is a message'&#13;
```&#13;
&#13;
git stash支持隐藏指定文件，在隐藏指定文件时，不能省略push参数，必须使用完整的命令&#13;
```shell&#13;
git stash push **/*.java&#13;
git stash push -m 'This is a message' **/*.java&#13;
```&#13;
&#13;
# 使用指定的隐藏记录&#13;
一般情况下使用指定的隐藏记录命令是&#13;
```shell&#13;
git stash pop [index]&#13;
```&#13;
&#13;
在没有冲突的情况下，这个命令会把隐藏给删除。</description><guid isPermaLink="true">https://paimonlee.github.io/paimon.github.io/post/%E3%80%90Git%E3%80%91stash.html</guid><pubDate>Thu, 20 Jun 2024 07:42:49 +0000</pubDate></item><item><title>协程</title><link>https://paimonlee.github.io/paimon.github.io/post/xie-cheng.html</link><description># 关键词&#13;
&#13;
coroutine、yield、next、send&#13;
&#13;
# 协程（coroutine）&#13;
&#13;
协作式多任务的子程序，允许执行被挂起与被恢复。</description><guid isPermaLink="true">https://paimonlee.github.io/paimon.github.io/post/xie-cheng.html</guid><pubDate>Thu, 20 Jun 2024 03:59:38 +0000</pubDate></item></channel></rss>